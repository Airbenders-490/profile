
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>http: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/airbenders/profile/Review/delivery/http/review_delivery.go (75.8%)</option>
				
				<option value="file1">github.com/airbenders/profile/Review/usecase/review_usecase.go (87.5%)</option>
				
				<option value="file2">github.com/airbenders/profile/School/delivery/http/school_delivery.go (87.2%)</option>
				
				<option value="file3">github.com/airbenders/profile/School/usecase/school_usecase.go (72.7%)</option>
				
				<option value="file4">github.com/airbenders/profile/Student/delivery/http/student.go (88.9%)</option>
				
				<option value="file5">github.com/airbenders/profile/Student/usecase/student_usecase.go (96.3%)</option>
				
				<option value="file6">github.com/airbenders/profile/Tag/delivery/http/tag_delivery.go (80.0%)</option>
				
				<option value="file7">github.com/airbenders/profile/Tag/usecase/tag_usecase.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package http

import (
        "fmt"
        "net/http"

        "github.com/airbenders/profile/domain"
        "github.com/airbenders/profile/utils/errors"
        "github.com/gin-gonic/gin"
)

// ReviewHandler struct
type ReviewHandler struct {
        u domain.ReviewUseCase
}

// NewReviewHandler is the constructor
func NewReviewHandler(ru domain.ReviewUseCase) *ReviewHandler <span class="cov8" title="1">{
        return &amp;ReviewHandler{u: ru}
}</span>

// AddReview binds review body and forwards it to the useCase for processing
func (h *ReviewHandler) AddReview(c *gin.Context) <span class="cov8" title="1">{
        reviewed := c.Param("reviewed")
        if reviewed == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("must provide reviewed id"))
                return
        }</span>

        <span class="cov8" title="1">var review domain.Review
        err := c.ShouldBindJSON(&amp;review)
        if err != nil || review.Reviewed.ID == "" || review.Tags == nil </span><span class="cov8" title="1">{
                fmt.Println(review, err.Error())
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("invalid review body"))
                return
        }</span>

        <span class="cov8" title="1">loggedID, _ := c.Get("loggedID")
        reviewer, _ := loggedID.(string)

        ctx := c.Request.Context()
        createdReview, err := h.u.AddReview(ctx, &amp;review, reviewer)
        if err != nil </span><span class="cov8" title="1">{
                switch v := err.(type) </span>{
                case *errors.RestError:<span class="cov8" title="1">
                        c.JSON(v.Code, v)
                        return</span>
                default:<span class="cov8" title="1">
                        c.JSON(http.StatusInternalServerError, errors.NewInternalServerError(err.Error()))
                        return</span>
                }
        }

        <span class="cov8" title="1">c.JSON(http.StatusCreated, createdReview)</span>
}

// EditReview alters the tags for the review
func (h *ReviewHandler) EditReview(c *gin.Context) <span class="cov8" title="1">{
        reviewed := c.Param("reviewed")
        if reviewed == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("must provide reviewed id"))
                return
        }</span>

        <span class="cov8" title="1">var review domain.Review
        err := c.ShouldBindJSON(&amp;review)
        if err != nil || review.Reviewed.ID == "" || review.Tags == nil </span><span class="cov8" title="1">{
                fmt.Println(review, err.Error())
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("invalid review body"))
                return
        }</span>

        <span class="cov8" title="1">ctx := c.Request.Context()

        loggedID, _ := c.Get("loggedID")
        reviewer, _ := loggedID.(string)

        updatedReview, err := h.u.EditReview(ctx, &amp;review, reviewer)
        if err != nil </span><span class="cov8" title="1">{
                switch v := err.(type) </span>{
                case *errors.RestError:<span class="cov8" title="1">
                        c.JSON(v.Code, v)
                        return</span>
                default:<span class="cov8" title="1">
                        c.JSON(http.StatusInternalServerError, errors.NewInternalServerError(err.Error()))
                        return</span>
                }
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, updatedReview)</span>
}

// GetReviewsBy returns the reviews made by that student
func (h *ReviewHandler) GetReviewsBy(c *gin.Context) <span class="cov8" title="1">{
        reviewer := c.Param("reviewer")
        if reviewer == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("must provide reviewer id"))
                return
        }</span>

        <span class="cov8" title="1">loggedID, _ := c.Get("loggedID")
        logged, _ := loggedID.(string)
        if logged != reviewer </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, errors.NewUnauthorizedError("not allowed to get reviews by others"))
                return
        }</span>

        <span class="cov8" title="1">if loggedID != reviewer </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, errors.NewUnauthorizedError("not authorized to edit this review"))
                return
        }</span>

        <span class="cov8" title="1">if loggedID != reviewer </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, errors.NewUnauthorizedError("not authorized to edit this review"))
        }</span>

        <span class="cov8" title="1">ctx := c.Request.Context()
        reviews, err := h.u.GetReviewsBy(ctx, reviewer)
        if err != nil </span><span class="cov0" title="0">{
                switch v := err.(type) </span>{
                case *errors.RestError:<span class="cov0" title="0">
                        c.JSON(v.Code, v)
                        return</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, errors.NewInternalServerError(err.Error()))
                        return</span>
                }
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, reviews)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package usecase

import (
        "context"
        "reflect"
        "time"

        "github.com/airbenders/profile/domain"
        "github.com/airbenders/profile/utils/errors"
        "github.com/google/uuid"
)

// reviewUseCase struct implements ReviewUseCase interface
type reviewUseCase struct {
        rr      domain.ReviewRepository
        sr      domain.StudentRepository
        timeout time.Duration
}

// NewReviewUseCase is the constructor
func NewReviewUseCase(rr domain.ReviewRepository, sr domain.StudentRepository, timeout time.Duration) domain.ReviewUseCase <span class="cov8" title="1">{
        return &amp;reviewUseCase{
                rr:      rr,
                sr:      sr,
                timeout: timeout,
        }
}</span>

// AddReview first checks if the person being reviewed exists.
func (u *reviewUseCase) AddReview(c context.Context, review *domain.Review, reviewerID string) (*domain.Review, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, u.timeout)
        defer cancel()

        student, err := u.sr.GetByID(ctx, review.Reviewed.ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if reflect.DeepEqual(student, &amp;domain.Student{}) </span><span class="cov0" title="0">{
                return nil, errors.NewBadRequestError("the person being reviewed doesn't exist")
        }</span>

        <span class="cov8" title="1">anyExistingReview, err := u.rr.GetReviewByAndFor(ctx, reviewerID, review.Reviewed.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(anyExistingReview, &amp;domain.Review{}) &amp;&amp; anyExistingReview != nil </span><span class="cov8" title="1">{
                return nil, errors.NewBadRequestError("the review already exists. Please update instead.")
        }</span>

        <span class="cov8" title="1">review.Reviewer.ID = reviewerID
        review.ID = uuid.NewString()
        review.CreatedAt = time.Now()

        err = u.rr.AddReview(ctx, review)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">review.Reviewed = *student
        return review, nil</span>
}

func (u *reviewUseCase) EditReview(c context.Context, review *domain.Review, reviewerID string) (*domain.Review, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, u.timeout)
        defer cancel()

        if review.ID == "" </span><span class="cov0" title="0">{
                return nil, errors.NewBadRequestError("review ID must be provided")
        }</span>

        <span class="cov8" title="1">student, err := u.sr.GetByID(ctx, review.Reviewed.ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if reflect.DeepEqual(student, &amp;domain.Student{}) </span><span class="cov0" title="0">{
                return nil, errors.NewBadRequestError("the person being reviewed doesn't exist")
        }</span>

        <span class="cov8" title="1">anyExistingReview, err := u.rr.GetReviewByAndFor(ctx, reviewerID, review.Reviewed.ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if reflect.DeepEqual(anyExistingReview, &amp;domain.Review{}) || anyExistingReview == nil </span><span class="cov0" title="0">{
                return nil, errors.NewBadRequestError("the review doesn't exists. Please create instead.")
        }</span>

        <span class="cov8" title="1">review.Reviewer.ID = reviewerID
        review.CreatedAt = time.Now()

        err = u.rr.UpdateReviewTags(ctx, review)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">review.Reviewed = *student
        return review, nil</span>
}

func (u *reviewUseCase) GetReviewsBy(c context.Context, reviewer string) ([]domain.Review, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, u.timeout)
        defer cancel()

        reviews, err := u.rr.GetReviewsBy(ctx, reviewer)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return reviews, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package http

import (
        "github.com/airbenders/profile/domain"
        "github.com/airbenders/profile/utils/errors"
        "github.com/airbenders/profile/utils/httputils"
        "github.com/gin-gonic/gin"
        "net/http"
        "reflect"
)

// SchoolHandler struct
type SchoolHandler struct {
        u domain.SchoolUseCase
}

// NewSchoolHandler returns a new SchoolHandler
func NewSchoolHandler(u domain.SchoolUseCase) *SchoolHandler <span class="cov8" title="1">{
        return &amp;SchoolHandler{u}
}</span>

// SearchStudentSchool is an endpoint that returns schools that matches the name
func (h *SchoolHandler) SearchStudentSchool(c *gin.Context) <span class="cov8" title="1">{
        domainName, ok := c.GetQuery("domain")
        if !ok || domainName == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("please provide a query"))
                return
        }</span>

        <span class="cov8" title="1">ctx := c.Request.Context()
        schools, err := h.u.SearchSchoolByDomain(ctx, domainName)
        if err != nil </span><span class="cov8" title="1">{
                switch v := err.(type) </span>{
                case *errors.RestError:<span class="cov0" title="0">
                        c.JSON(v.Code, v)
                        return</span>
                default:<span class="cov8" title="1">
                        c.JSON(http.StatusInternalServerError, errors.NewInternalServerError(err.Error()))
                        return</span>
                }
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, schools)</span>
}

// SendConfirmationMail sends email to the client for school confirmation
func (h *SchoolHandler) SendConfirmationMail(c *gin.Context) <span class="cov8" title="1">{
        ctx := c.Request.Context()
        email := c.Query("email")
        if email == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("must provide a valid email"))
                return
        }</span>
        <span class="cov8" title="1">var school domain.School
        err := c.ShouldBindJSON(&amp;school)
        if err != nil || reflect.DeepEqual(school, domain.School{}) </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("must provide valid data"))
                return
        }</span>

        <span class="cov8" title="1">key, _ := c.Get("loggedID")
        loggedID, _ := key.(string)

        err = h.u.SendConfirmation(ctx, &amp;domain.Student{ID: loggedID}, email, &amp;school)
        if err != nil </span><span class="cov8" title="1">{
                switch v := err.(type) </span>{
                case *errors.RestError:<span class="cov0" title="0">
                        c.JSON(v.Code, v)
                        return</span>
                default:<span class="cov8" title="1">
                        c.JSON(http.StatusInternalServerError, errors.NewInternalServerError(err.Error()))
                        return</span>
                }
        }

        <span class="cov8" title="1">c.JSON(200, httputils.NewResponse("email sent"))</span>
}

// ConfirmSchoolRegistration is an internal endpoint (not accessible from the app) that is embedded in the email
func (h *SchoolHandler) ConfirmSchoolRegistration(c *gin.Context) <span class="cov8" title="1">{
        ctx := c.Request.Context()
        token := c.Query("token")
        if token == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("must provide a valid email"))
                return
        }</span>

        <span class="cov8" title="1">err := h.u.ConfirmSchoolEnrollment(ctx, token)
        if err != nil </span><span class="cov8" title="1">{
                switch v := err.(type) </span>{
                case *errors.RestError:<span class="cov0" title="0">
                        c.JSON(v.Code, v)
                        return</span>
                default:<span class="cov8" title="1">
                        c.JSON(http.StatusInternalServerError, errors.NewInternalServerError(err.Error()))
                        return</span>
                }
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, httputils.NewResponse("school confirmed"))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package usecase

import (
        "bytes"
        "context"
        "fmt"
        "github.com/airbenders/profile/domain"
        "github.com/airbenders/profile/utils"
        "github.com/airbenders/profile/utils/errors"
        "github.com/google/uuid"
        "log"
        "os"
        "reflect"
        "strings"
        "text/template"
        "time"
)

type schoolUseCase struct {
        r       domain.SchoolRepository
        str     domain.StudentRepository
        mailer  utils.Mailer
        timeout time.Duration
}

// NewSchoolUseCase is the constructor
func NewSchoolUseCase(r domain.SchoolRepository, str domain.StudentRepository, mailer utils.Mailer, timeout time.Duration) domain.SchoolUseCase <span class="cov8" title="1">{
        return &amp;schoolUseCase{r, str, mailer, timeout}
}</span>

// SearchSchoolByDomain doesn't do much processing. just returns the school slice if received from the repository.
// returns nil and 404 error if there are no schools
func (s *schoolUseCase) SearchSchoolByDomain(c context.Context, domainName string) ([]domain.School, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, s.timeout)
        defer cancel()

        domainNameLike := parseDomainName(domainName)
        schools, err := s.r.SearchByDomain(ctx, domainNameLike)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.NewInternalServerError(err.Error())
        }</span>
        <span class="cov8" title="1">if len(schools) == 0 </span><span class="cov8" title="1">{
                return nil, errors.NewNotFoundError(fmt.Sprintf("no school with domain name %s exists", domainName))
        }</span>

        <span class="cov8" title="1">return schools, nil</span>
}

func parseDomainName(name string) string <span class="cov8" title="1">{
        var domains []string
        // first add the same domain as we got: e.g. live.concordia.ca to it
        domains = append(domains, name)
        count := strings.Count(name, ".")
        // live.concordia.ca has 2
        if count &gt; 1 </span><span class="cov0" title="0">{
                if first := strings.Index(name, "."); first != len(name) </span><span class="cov0" title="0">{
                        // extract the latter half like concordia.ca and add it to domains
                        name = name[first+1:]
                        domains = append(domains, name)
                }</span>
        }
        // string builder
        <span class="cov8" title="1">var domainNameLike bytes.Buffer
        // write the first one. This shouldn't be an error
        _, err := domainNameLike.WriteString(domains[0])
        if err != nil </span><span class="cov0" title="0">{
                log.Println("ISSUE!")
        }</span>
        // for the rest, add them with an 'or' operator
        <span class="cov8" title="1">for _, domainName := range domains[1:] </span><span class="cov0" title="0">{
                domainNameLike.WriteString(fmt.Sprintf("|%s", domainName))
        }</span>
        <span class="cov8" title="1">return domainNameLike.String()</span>
}

// SendConfirmation sends an email to the student's school email address with a generated token
// also stores the token in the repository with the student's and school's IDs for confirmation later
func (s *schoolUseCase) SendConfirmation(c context.Context, st *domain.Student, email string, school *domain.School) error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, s.timeout)
        defer cancel()

        student, err := s.str.GetByID(ctx, st.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if reflect.DeepEqual(student, &amp;domain.Student{}) </span><span class="cov8" title="1">{
                return errors.NewNotFoundError("student not found")
        }</span>
        <span class="cov8" title="1">if student.School != nil </span><span class="cov8" title="1">{
                return errors.NewBadRequestError("school already confirmed")
        }</span>

        <span class="cov8" title="1">token := uuid.New().String()
        domainName := os.Getenv("DOMAIN")
        if domainName == "" </span><span class="cov0" title="0">{
                log.Fatalln("Domain name not provided")
        }</span>
        <span class="cov8" title="1">confirmationURL := fmt.Sprintf("%s/school/confirmation", domainName)
        url := fmt.Sprintf("%s?token=%s", confirmationURL, token)

        confirmation := &amp;domain.Confirmation{
                Token:     token,
                School:    *school,
                Student:   *st,
                CreatedAt: time.Now(),
        }

        err = s.r.SaveConfirmationToken(ctx, confirmation)
        if err != nil </span><span class="cov8" title="1">{
                return errors.NewInternalServerError(err.Error())
        }</span>

        <span class="cov0" title="0">body := createEmailBody(student.FirstName, school.Name, url)
        return s.mailer.SendSimpleMail(email, body)</span>
}

func createEmailBody(name, school, url string) []byte <span class="cov0" title="0">{
        t, err := template.ParseFiles("static/confirmation_template.html")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>
        <span class="cov0" title="0">var body bytes.Buffer
        mimeHeaders := "MIME-version: 1.0;\nContent-Type: text/html; charset=\"UTF-8\";\n\n"
        body.Write([]byte(fmt.Sprintf("Subject: Anonymous app confirmation email\n%s\n\n", mimeHeaders)))
        t.Execute(&amp;body, struct {
                Name   string
                School string
                Email  string
        }{
                Name:   name,
                School: school,
                Email:  url,
        })

        return body.Bytes()</span>
}

// ConfirmSchoolEnrollment checks if the record for the token exists in the repository.
// if it does, it checks to ensure it's more than 24 hours old
func (s *schoolUseCase) ConfirmSchoolEnrollment(c context.Context, token string) error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, s.timeout)
        defer cancel()

        confirmation, err := s.r.GetConfirmationByToken(ctx, token)
        if err != nil </span><span class="cov8" title="1">{
                return errors.NewInternalServerError(err.Error())
        }</span>
        <span class="cov8" title="1">if reflect.DeepEqual(*confirmation, domain.Confirmation{}) </span><span class="cov8" title="1">{
                return errors.NewNotFoundError("invalid token")
        }</span>
        <span class="cov8" title="1">if confirmation.CreatedAt.Add(time.Hour * 24).Before(time.Now()) </span><span class="cov8" title="1">{
                return errors.NewBadRequestError("token already expired")
        }</span>

        <span class="cov8" title="1">err = s.r.AddSchoolForStudent(ctx, confirmation.Student.ID, confirmation.School.ID)
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewInternalServerError(err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package http

import (
        "github.com/airbenders/profile/domain"
        "github.com/airbenders/profile/utils/errors"
        "github.com/airbenders/profile/utils/httputils"
        "github.com/gin-gonic/gin"
        "net/http"
)

// StudentHandler struct
type StudentHandler struct {
        UseCase domain.StudentUseCase
}

// NewStudentHandler is the constructor
func NewStudentHandler(u domain.StudentUseCase) *StudentHandler <span class="cov8" title="1">{
        return &amp;StudentHandler{UseCase: u}
}</span>

// GetByID returns the student's profile with that ID. If it doesn't exist, returns 404
func (h *StudentHandler) GetByID(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")
        if id == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("id must be provided"))
                return
        }</span>
        <span class="cov8" title="1">ctx := c.Request.Context()
        student, err := h.UseCase.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                switch v := err.(type) </span>{
                case *errors.RestError:<span class="cov8" title="1">
                        c.JSON(v.Code, v)
                        return</span>
                default:<span class="cov8" title="1">
                        c.JSON(http.StatusInternalServerError, errors.NewInternalServerError(err.Error()))
                        return</span>
                }
        }
        <span class="cov8" title="1">c.JSON(200, student)</span>
}

// Create is hit when the student first creates his account and is asked to set it up.
func (h *StudentHandler) Create(c *gin.Context) <span class="cov8" title="1">{
        key, _ := c.Get("loggedID")
        loggedID, _ := key.(string)

        var student domain.Student
        err := c.ShouldBindJSON(&amp;student)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("invalid data"))
                return
        }</span>
        <span class="cov8" title="1">student.ID = loggedID

        ctx := c.Request.Context()
        err = h.UseCase.Create(ctx, &amp;student)
        if err != nil </span><span class="cov8" title="1">{
                switch v := err.(type) </span>{
                case *errors.RestError:<span class="cov8" title="1">
                        c.JSON(v.Code, v)
                        return</span>
                default:<span class="cov8" title="1">
                        c.JSON(http.StatusInternalServerError, errors.NewInternalServerError(err.Error()))
                        return</span>
                }
        }

        <span class="cov8" title="1">c.JSON(http.StatusCreated, httputils.NewResponse("student created"))</span>
}

// Update changes the student record. Ensures the student is the same as logged in, and then makes changes as requested
func (h *StudentHandler) Update(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")
        if id == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("id must be provided"))
                return
        }</span>

        <span class="cov8" title="1">key, _ := c.Get("loggedID")
        loggedID, _ := key.(string)

        if loggedID != id </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, errors.NewUnauthorizedError("Can only update for self"))
                return
        }</span>

        <span class="cov8" title="1">var student domain.Student
        err := c.ShouldBindJSON(&amp;student)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("invalid data"))
                return
        }</span>

        <span class="cov8" title="1">ctx := c.Request.Context()
        err = h.UseCase.Update(ctx, id, &amp;student)
        if err != nil </span><span class="cov8" title="1">{
                switch v := err.(type) </span>{
                case *errors.RestError:<span class="cov8" title="1">
                        c.JSON(v.Code, v)
                        return</span>
                default:<span class="cov8" title="1">
                        c.JSON(http.StatusInternalServerError, errors.NewInternalServerError(err.Error()))
                        return</span>
                }
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, httputils.NewResponse("student updated"))</span>
}

// Delete simply deletes the profile as requested
func (h *StudentHandler) Delete(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")
        if id == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, errors.NewBadRequestError("id must be provided"))
                return
        }</span>

        <span class="cov8" title="1">key, _ := c.Get("loggedID")
        loggedID, _ := key.(string)

        if loggedID != id </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, errors.NewUnauthorizedError("Can only delete for self"))
                return
        }</span>

        <span class="cov8" title="1">ctx := c.Request.Context()
        err := h.UseCase.Delete(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                switch v := err.(type) </span>{
                case *errors.RestError:<span class="cov8" title="1">
                        c.JSON(v.Code, v)
                        return</span>
                default:<span class="cov8" title="1">
                        c.JSON(http.StatusInternalServerError, errors.NewInternalServerError(err.Error()))
                        return</span>
                }
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, httputils.NewResponse("student deleted"))</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package usecase

import (
        "context"
        "fmt"
        "github.com/airbenders/profile/domain"
        "github.com/airbenders/profile/utils/errors"
        "log"
        "reflect"
        "time"
)

type studentUseCase struct {
        studentRepository domain.StudentRepository
        //TODO: add review and possibly tag repositories to fetch their data too
        reviewRepository domain.ReviewRepository
        contextTimeout   time.Duration
}

// NewStudentUseCase returns a configured StudentUseCase
func NewStudentUseCase(sr domain.StudentRepository, rr domain.ReviewRepository, timeout time.Duration) domain.StudentUseCase <span class="cov8" title="1">{
        return &amp;studentUseCase{
                studentRepository: sr,
                reviewRepository:  rr,
                contextTimeout:    timeout,
        }
}</span>

// Create stores the student in the db. ID must be provided or return an error
func (s *studentUseCase) Create(c context.Context, st *domain.Student) error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, s.contextTimeout)
        defer cancel()

        if st.ID != "" </span><span class="cov8" title="1">{
                existingStudent, err := s.studentRepository.GetByID(ctx, st.ID)
                if err == nil </span><span class="cov8" title="1">{
                        if !reflect.DeepEqual(*existingStudent, domain.Student{}) </span><span class="cov8" title="1">{
                                return errors.NewConflictError(fmt.Sprintf("Student with ID %s already exists", st.ID))
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                return errors.NewBadRequestError("The student should have an ID from auth service")
        }</span>

        <span class="cov8" title="1">st.CreatedAt = time.Now()
        st.UpdatedAt = time.Now()
        err := s.studentRepository.Create(ctx, st.ID, st)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetByID seeks student from repo layer and returns if it exists, else return error
func (s *studentUseCase) GetByID(c context.Context, id string) (*domain.Student, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, s.contextTimeout)
        defer cancel()

        student, err := s.studentRepository.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if reflect.DeepEqual(student, &amp;domain.Student{}) </span><span class="cov8" title="1">{
                return nil, errors.NewNotFoundError(fmt.Sprintf("No such student with ID %s exists", id))
        }</span>

        <span class="cov8" title="1">reviews, err := s.reviewRepository.GetReviewsFor(ctx, student.ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Can't get the reviews right now.")
        }</span>
        <span class="cov8" title="1">student.Reviews = reviews

        return student, nil</span>
}

// Update checks if the student exists and updates if so. Otherwise, returns error
func (s *studentUseCase) Update(c context.Context, id string, st *domain.Student) error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, s.contextTimeout)
        defer cancel()

        st.ID = id
        existingStudent, err := s.studentRepository.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if reflect.DeepEqual(existingStudent, &amp;domain.Student{}) </span><span class="cov8" title="1">{
                return errors.NewNotFoundError(fmt.Sprintf("No such student with ID %s exists", st.ID))
        }</span>
        <span class="cov8" title="1">updateStudent(existingStudent, st)
        return s.studentRepository.Update(ctx, existingStudent)</span>
}

func updateStudent(existing *domain.Student, toUpdate *domain.Student) <span class="cov8" title="1">{
        if toUpdate.FirstName != "" </span><span class="cov8" title="1">{
                existing.FirstName = toUpdate.FirstName
        }</span>
        <span class="cov8" title="1">if toUpdate.LastName != "" </span><span class="cov8" title="1">{
                existing.LastName = toUpdate.LastName
        }</span>
        <span class="cov8" title="1">if toUpdate.Email != "" </span><span class="cov8" title="1">{
                existing.Email = toUpdate.Email
        }</span>
        <span class="cov8" title="1">if toUpdate.GeneralInfo != "" </span><span class="cov8" title="1">{
                existing.GeneralInfo = toUpdate.GeneralInfo
        }</span>
        <span class="cov8" title="1">existing.UpdatedAt = time.Now()</span>
}

// Delete removes the student if it exists. Otherwise, returns error
func (s *studentUseCase) Delete(c context.Context, id string) error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, s.contextTimeout)
        defer cancel()

        existingStudent, err := s.studentRepository.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if reflect.DeepEqual(existingStudent, &amp;domain.Student{}) </span><span class="cov8" title="1">{
                return errors.NewNotFoundError(fmt.Sprintf("No such student with ID %s exists", id))
        }</span>

        <span class="cov8" title="1">return s.studentRepository.Delete(ctx, id)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package http

import (
        "github.com/airbenders/profile/domain"
        "github.com/airbenders/profile/utils/errors"
        "github.com/gin-gonic/gin"
        "net/http"
)

// TagHandler struct
type TagHandler struct {
        u domain.TagUseCase
}

// NewTagHandler is a constructor
func NewTagHandler(u domain.TagUseCase) *TagHandler <span class="cov8" title="1">{
        return &amp;TagHandler{u: u}
}</span>

// GetAllTags returns all the tags currently available
func (h *TagHandler) GetAllTags(c *gin.Context) <span class="cov8" title="1">{
        ctx := c.Request.Context()

        tags, err := h.u.GetAllTags(ctx)
        if err != nil </span><span class="cov8" title="1">{
                switch v := err.(type) </span>{
                case *errors.RestError:<span class="cov0" title="0">
                        c.JSON(v.Code, v)
                        return</span>
                default:<span class="cov8" title="1">
                        c.JSON(http.StatusInternalServerError, errors.NewInternalServerError(err.Error()))
                        return</span>
                }
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, tags)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package usecase

import (
        "context"
        "github.com/airbenders/profile/domain"
        "time"
)

// tagUseCase struct
type tagUseCase struct {
        r       domain.TagRepository
        timeout time.Duration
}

// NewTagUseCase is a constructor for tagUseCase
func NewTagUseCase(r domain.TagRepository, timeout time.Duration) domain.TagUseCase <span class="cov8" title="1">{
        return &amp;tagUseCase{r: r, timeout: timeout}
}</span>

// GetAllTags returns all the tags
func (u *tagUseCase) GetAllTags(c context.Context) ([]domain.Tag, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c, u.timeout)
        defer cancel()

        tags, err := u.r.FetchAllTags(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return tags, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
